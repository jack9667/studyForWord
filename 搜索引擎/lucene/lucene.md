### 1.打分机制：
    https://juejin.im/post/58ecd21461ff4b0058154fd9
    https://www.cnblogs.com/forfuture1978/archive/2009/12/14/1623594.html
    
### 分建索引和查询：
#### 建索引：
    对docment文档用分词组件和语言处理组件处理，得到term（分词主要就是切词去停词，语言组件做小写和词根变化之类)；对得到的term创建词典，并排序，合并所有term创建倒排表（节点包括文档docid，term
        出现文档数和在每个文档中出现的次数，倒排链有跳表结构）；这里term词典表为了省内存构建出fst结构；
        merge.policy.sort.field=time；在term阶段选定字段对倒排链排序，做截断，避免merge的时候过大
        $flexibleQuery：在原基础上做二次排序query的term和filed进行遍历，（filed不分词，query分词）返回打分函数，只对top进行排序减小时间（feild指定boost分，命中就提权，同时相邻term命中顺序+1，再乘上一个时间权重(当前时间-更新时间取e对数)）

#### 查询：
    经过词法分析和语法分析，对query构建语法树（包括关键词和普通单词，关键词and or not 与或非），搜索fst得到每个词的倒排链表，合并，对得到的文档链进行排序；排序采用空间向量算法，将query和doc
    以term为基础映射到同一个维度的向量上，用term的每个tfidf表示维度值，求query和doc的cos作为排序结果

#### fst：
    前缀和后缀公用的一种有限状态机，且是无环的，每一个节点是一种状态，输入的字符改变状态的转移，同时能够处理输出，是一种kv格式结构，不仅能判断key是否存在，还能得到输出的值；构建时需要对term排序，输出的value
    可以用倒排链的头结点位置，这样直接定位倒排链的位置。

#### 压缩：
    数字压缩，1000，1001， 1002 -> 1000，1， 2 对数值只保留增量的数
#### 打分：
    得分因子+归一化因子